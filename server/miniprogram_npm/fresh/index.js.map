{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*!\r\n * fresh\r\n * Copyright(c) 2012 TJ Holowaychuk\r\n * Copyright(c) 2016-2017 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n\r\n\r\n/**\r\n * RegExp to check for no-cache token in Cache-Control.\r\n * @private\r\n */\r\n\r\nvar CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\\s*?no-cache\\s*?(?:,|$)/\r\n\r\n/**\r\n * Module exports.\r\n * @public\r\n */\r\n\r\nmodule.exports = fresh\r\n\r\n/**\r\n * Check freshness of the response using request and response headers.\r\n *\r\n * @param {Object} reqHeaders\r\n * @param {Object} resHeaders\r\n * @return {Boolean}\r\n * @public\r\n */\r\n\r\nfunction fresh (reqHeaders, resHeaders) {\r\n  // fields\r\n  var modifiedSince = reqHeaders['if-modified-since']\r\n  var noneMatch = reqHeaders['if-none-match']\r\n\r\n  // unconditional request\r\n  if (!modifiedSince && !noneMatch) {\r\n    return false\r\n  }\r\n\r\n  // Always return stale when Cache-Control: no-cache\r\n  // to support end-to-end reload requests\r\n  // https://tools.ietf.org/html/rfc2616#section-14.9.4\r\n  var cacheControl = reqHeaders['cache-control']\r\n  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {\r\n    return false\r\n  }\r\n\r\n  // if-none-match\r\n  if (noneMatch && noneMatch !== '*') {\r\n    var etag = resHeaders['etag']\r\n\r\n    if (!etag) {\r\n      return false\r\n    }\r\n\r\n    var etagStale = true\r\n    var matches = parseTokenList(noneMatch)\r\n    for (var i = 0; i < matches.length; i++) {\r\n      var match = matches[i]\r\n      if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {\r\n        etagStale = false\r\n        break\r\n      }\r\n    }\r\n\r\n    if (etagStale) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  // if-modified-since\r\n  if (modifiedSince) {\r\n    var lastModified = resHeaders['last-modified']\r\n    var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))\r\n\r\n    if (modifiedStale) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  return true\r\n}\r\n\r\n/**\r\n * Parse an HTTP Date into a number.\r\n *\r\n * @param {string} date\r\n * @private\r\n */\r\n\r\nfunction parseHttpDate (date) {\r\n  var timestamp = date && Date.parse(date)\r\n\r\n  // istanbul ignore next: guard against date.js Date.parse patching\r\n  return typeof timestamp === 'number'\r\n    ? timestamp\r\n    : NaN\r\n}\r\n\r\n/**\r\n * Parse a HTTP token list.\r\n *\r\n * @param {string} str\r\n * @private\r\n */\r\n\r\nfunction parseTokenList (str) {\r\n  var end = 0\r\n  var list = []\r\n  var start = 0\r\n\r\n  // gather tokens\r\n  for (var i = 0, len = str.length; i < len; i++) {\r\n    switch (str.charCodeAt(i)) {\r\n      case 0x20: /*   */\r\n        if (start === end) {\r\n          start = end = i + 1\r\n        }\r\n        break\r\n      case 0x2c: /* , */\r\n        list.push(str.substring(start, end))\r\n        start = end = i + 1\r\n        break\r\n      default:\r\n        end = i + 1\r\n        break\r\n    }\r\n  }\r\n\r\n  // final token\r\n  list.push(str.substring(start, end))\r\n\r\n  return list\r\n}\r\n"]}