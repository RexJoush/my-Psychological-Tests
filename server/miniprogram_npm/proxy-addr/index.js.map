{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/*!\r\n * proxy-addr\r\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n\r\n\r\n/**\r\n * Module exports.\r\n * @public\r\n */\r\n\r\nmodule.exports = proxyaddr\r\nmodule.exports.all = alladdrs\r\nmodule.exports.compile = compile\r\n\r\n/**\r\n * Module dependencies.\r\n * @private\r\n */\r\n\r\nvar forwarded = require('forwarded')\r\nvar ipaddr = require('ipaddr.js')\r\n\r\n/**\r\n * Variables.\r\n * @private\r\n */\r\n\r\nvar DIGIT_REGEXP = /^[0-9]+$/\r\nvar isip = ipaddr.isValid\r\nvar parseip = ipaddr.parse\r\n\r\n/**\r\n * Pre-defined IP ranges.\r\n * @private\r\n */\r\n\r\nvar IP_RANGES = {\r\n  linklocal: ['169.254.0.0/16', 'fe80::/10'],\r\n  loopback: ['127.0.0.1/8', '::1/128'],\r\n  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']\r\n}\r\n\r\n/**\r\n * Get all addresses in the request, optionally stopping\r\n * at the first untrusted.\r\n *\r\n * @param {Object} request\r\n * @param {Function|Array|String} [trust]\r\n * @public\r\n */\r\n\r\nfunction alladdrs (req, trust) {\r\n  // get addresses\r\n  var addrs = forwarded(req)\r\n\r\n  if (!trust) {\r\n    // Return all addresses\r\n    return addrs\r\n  }\r\n\r\n  if (typeof trust !== 'function') {\r\n    trust = compile(trust)\r\n  }\r\n\r\n  for (var i = 0; i < addrs.length - 1; i++) {\r\n    if (trust(addrs[i], i)) continue\r\n\r\n    addrs.length = i + 1\r\n  }\r\n\r\n  return addrs\r\n}\r\n\r\n/**\r\n * Compile argument into trust function.\r\n *\r\n * @param {Array|String} val\r\n * @private\r\n */\r\n\r\nfunction compile (val) {\r\n  if (!val) {\r\n    throw new TypeError('argument is required')\r\n  }\r\n\r\n  var trust\r\n\r\n  if (typeof val === 'string') {\r\n    trust = [val]\r\n  } else if (Array.isArray(val)) {\r\n    trust = val.slice()\r\n  } else {\r\n    throw new TypeError('unsupported trust argument')\r\n  }\r\n\r\n  for (var i = 0; i < trust.length; i++) {\r\n    val = trust[i]\r\n\r\n    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {\r\n      continue\r\n    }\r\n\r\n    // Splice in pre-defined range\r\n    val = IP_RANGES[val]\r\n    trust.splice.apply(trust, [i, 1].concat(val))\r\n    i += val.length - 1\r\n  }\r\n\r\n  return compileTrust(compileRangeSubnets(trust))\r\n}\r\n\r\n/**\r\n * Compile `arr` elements into range subnets.\r\n *\r\n * @param {Array} arr\r\n * @private\r\n */\r\n\r\nfunction compileRangeSubnets (arr) {\r\n  var rangeSubnets = new Array(arr.length)\r\n\r\n  for (var i = 0; i < arr.length; i++) {\r\n    rangeSubnets[i] = parseipNotation(arr[i])\r\n  }\r\n\r\n  return rangeSubnets\r\n}\r\n\r\n/**\r\n * Compile range subnet array into trust function.\r\n *\r\n * @param {Array} rangeSubnets\r\n * @private\r\n */\r\n\r\nfunction compileTrust (rangeSubnets) {\r\n  // Return optimized function based on length\r\n  var len = rangeSubnets.length\r\n  return len === 0\r\n    ? trustNone\r\n    : len === 1\r\n      ? trustSingle(rangeSubnets[0])\r\n      : trustMulti(rangeSubnets)\r\n}\r\n\r\n/**\r\n * Parse IP notation string into range subnet.\r\n *\r\n * @param {String} note\r\n * @private\r\n */\r\n\r\nfunction parseipNotation (note) {\r\n  var pos = note.lastIndexOf('/')\r\n  var str = pos !== -1\r\n    ? note.substring(0, pos)\r\n    : note\r\n\r\n  if (!isip(str)) {\r\n    throw new TypeError('invalid IP address: ' + str)\r\n  }\r\n\r\n  var ip = parseip(str)\r\n\r\n  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {\r\n    // Store as IPv4\r\n    ip = ip.toIPv4Address()\r\n  }\r\n\r\n  var max = ip.kind() === 'ipv6'\r\n    ? 128\r\n    : 32\r\n\r\n  var range = pos !== -1\r\n    ? note.substring(pos + 1, note.length)\r\n    : null\r\n\r\n  if (range === null) {\r\n    range = max\r\n  } else if (DIGIT_REGEXP.test(range)) {\r\n    range = parseInt(range, 10)\r\n  } else if (ip.kind() === 'ipv4' && isip(range)) {\r\n    range = parseNetmask(range)\r\n  } else {\r\n    range = null\r\n  }\r\n\r\n  if (range <= 0 || range > max) {\r\n    throw new TypeError('invalid range on address: ' + note)\r\n  }\r\n\r\n  return [ip, range]\r\n}\r\n\r\n/**\r\n * Parse netmask string into CIDR range.\r\n *\r\n * @param {String} netmask\r\n * @private\r\n */\r\n\r\nfunction parseNetmask (netmask) {\r\n  var ip = parseip(netmask)\r\n  var kind = ip.kind()\r\n\r\n  return kind === 'ipv4'\r\n    ? ip.prefixLengthFromSubnetMask()\r\n    : null\r\n}\r\n\r\n/**\r\n * Determine address of proxied request.\r\n *\r\n * @param {Object} request\r\n * @param {Function|Array|String} trust\r\n * @public\r\n */\r\n\r\nfunction proxyaddr (req, trust) {\r\n  if (!req) {\r\n    throw new TypeError('req argument is required')\r\n  }\r\n\r\n  if (!trust) {\r\n    throw new TypeError('trust argument is required')\r\n  }\r\n\r\n  var addrs = alladdrs(req, trust)\r\n  var addr = addrs[addrs.length - 1]\r\n\r\n  return addr\r\n}\r\n\r\n/**\r\n * Static trust function to trust nothing.\r\n *\r\n * @private\r\n */\r\n\r\nfunction trustNone () {\r\n  return false\r\n}\r\n\r\n/**\r\n * Compile trust function for multiple subnets.\r\n *\r\n * @param {Array} subnets\r\n * @private\r\n */\r\n\r\nfunction trustMulti (subnets) {\r\n  return function trust (addr) {\r\n    if (!isip(addr)) return false\r\n\r\n    var ip = parseip(addr)\r\n    var ipconv\r\n    var kind = ip.kind()\r\n\r\n    for (var i = 0; i < subnets.length; i++) {\r\n      var subnet = subnets[i]\r\n      var subnetip = subnet[0]\r\n      var subnetkind = subnetip.kind()\r\n      var subnetrange = subnet[1]\r\n      var trusted = ip\r\n\r\n      if (kind !== subnetkind) {\r\n        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {\r\n          // Incompatible IP addresses\r\n          continue\r\n        }\r\n\r\n        if (!ipconv) {\r\n          // Convert IP to match subnet IP kind\r\n          ipconv = subnetkind === 'ipv4'\r\n            ? ip.toIPv4Address()\r\n            : ip.toIPv4MappedAddress()\r\n        }\r\n\r\n        trusted = ipconv\r\n      }\r\n\r\n      if (trusted.match(subnetip, subnetrange)) {\r\n        return true\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Compile trust function for single subnet.\r\n *\r\n * @param {Object} subnet\r\n * @private\r\n */\r\n\r\nfunction trustSingle (subnet) {\r\n  var subnetip = subnet[0]\r\n  var subnetkind = subnetip.kind()\r\n  var subnetisipv4 = subnetkind === 'ipv4'\r\n  var subnetrange = subnet[1]\r\n\r\n  return function trust (addr) {\r\n    if (!isip(addr)) return false\r\n\r\n    var ip = parseip(addr)\r\n    var kind = ip.kind()\r\n\r\n    if (kind !== subnetkind) {\r\n      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {\r\n        // Incompatible IP addresses\r\n        return false\r\n      }\r\n\r\n      // Convert IP to match subnet IP kind\r\n      ip = subnetisipv4\r\n        ? ip.toIPv4Address()\r\n        : ip.toIPv4MappedAddress()\r\n    }\r\n\r\n    return ip.match(subnetip, subnetrange)\r\n  }\r\n}\r\n"]}